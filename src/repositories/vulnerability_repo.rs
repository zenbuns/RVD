use crate::db::connection::SqlitePool;
use crate::models::vulnerability::Vulnerability;
use rusqlite::params;
use std::sync::Arc;
use log::{error, debug};
use chrono::NaiveDate;
use anyhow::{Result, Context};
use tokio::task;

pub async fn add_vulnerability(pool: Arc<SqlitePool>, vulnerability: Vulnerability) -> Result<i64> {
    task::spawn_blocking(move || {
        let conn = pool.get().context("Failed to get database connection")?;

        let published_date = vulnerability.published_date.map(|date| date.format("%Y-%m-%d").to_string());

        let result = conn.execute(
            "INSERT INTO vulnerabilities (cve_id, description, severity, impact, mitigation, published_date)
             VALUES (?1, ?2, ?3, ?4, ?5, ?6)",
            params![
                vulnerability.cve_id,
                vulnerability.description,
                vulnerability.severity,
                vulnerability.impact,
                vulnerability.mitigation,
                published_date,
            ],
        ).context("Failed to execute INSERT query")?;

        if result != 1 {
            anyhow::bail!("Unexpected number of rows affected: {}", result);
        }

        let id = conn.last_insert_rowid();
        debug!("Inserted vulnerability with ID: {}", id);
        Ok(id)
    })
        .await
        .context("Failed to execute database operation")?
}

pub async fn get_all_vulnerabilities(pool: Arc<SqlitePool>) -> Result<Vec<Vulnerability>> {
    task::spawn_blocking(move || {
        let conn = pool.get().context("Failed to get database connection")?;

        let mut stmt = conn
            .prepare("SELECT vulnerability_id, cve_id, description, severity, impact, mitigation, published_date FROM vulnerabilities")
            .context("Failed to prepare SELECT query")?;

        let vulnerability_iter = stmt.query_map([], |row| {
            Ok(Vulnerability {
                vulnerability_id: row.get(0)?,
                cve_id: row.get(1)?,
                description: row.get(2)?,
                severity: row.get(3)?,
                impact: row.get(4)?,
                mitigation: row.get(5)?,
                published_date: row.get::<_, Option<String>>(6)?
                    .and_then(|d| NaiveDate::parse_from_str(&d, "%Y-%m-%d").ok()),
            })
        })
            .context("Failed to execute SELECT query")?;

        vulnerability_iter
            .collect::<rusqlite::Result<Vec<_>>>()
            .context("Failed to collect vulnerabilities")
    })
        .await
        .context("Failed to execute database operation")?
}

#[cfg(test)]
mod tests {
    use super::*;
    use chrono::NaiveDate;

    #[tokio::test]
    async fn test_crud_operations() -> Result<()> {
        let db_conn = DatabaseConnection::new().await?;
        let repo = VulnerabilityRepository::new(db_conn);

        // Test Create
        let vuln = Vulnerability {
            vulnerability_id: None,
            cve_id: "CVE-2024-TEST".to_string(),
            description: Some("Test vulnerability".to_string()),
            severity: "HIGH".to_string(),
            impact: Some("Test impact".to_string()),
            mitigation: Some("Test mitigation".to_string()),
            published_date: Some(NaiveDate::from_ymd_opt(2024, 1, 1).unwrap()),
        };

        let id = repo.add_vulnerability(vuln.clone()).await?;
        assert!(id > 0);

        // Test Read
        let retrieved = repo.get_vulnerability_by_id(id).await?;
        assert_eq!(retrieved.cve_id, vuln.cve_id);

        // Test Search
        let (results, total_pages) = repo.search_vulnerabilities("TEST", 0, 10).await?;
        assert!(!results.is_empty());
        assert!(total_pages > 0);

        // Test Update
        let mut updated = retrieved.clone();
        updated.description = Some("Updated description".to_string());
        repo.update_vulnerability(&updated).await?;

        let retrieved_updated = repo.get_vulnerability_by_id(id).await?;
        assert_eq!(retrieved_updated.description, updated.description);

        // Test Delete
        repo.delete_vulnerability(id).await?;
        let result = repo.get_vulnerability_by_id(id).await;
        assert!(result.is_err());

        Ok(())
    }

    #[tokio::test]
    async fn test_concurrent_operations() -> Result<()> {
        let db_conn = DatabaseConnection::new().await?;
        let repo = VulnerabilityRepository::new(db_conn);
        let repo_clone = repo.clone();

        let handle1 = tokio::spawn(async move {
            let vuln = Vulnerability {
                vulnerability_id: None,
                cve_id: "CVE-2024-TEST1".to_string(),
                description: Some("Test 1".to_string()),
                severity: "HIGH".to_string(),
                impact: None,
                mitigation: None,
                published_date: None,
            };
            repo.add_vulnerability(vuln).await
        });

        let handle2 = tokio::spawn(async move {
            let vuln = Vulnerability {
                vulnerability_id: None,
                cve_id: "CVE-2024-TEST2".to_string(),
                description: Some("Test 2".to_string()),
                severity: "MEDIUM".to_string(),
                impact: None,
                mitigation: None,
                published_date: None,
            };
            repo_clone.add_vulnerability(vuln).await
        });

        let (id1, id2) = tokio::join!(handle1, handle2);
        assert!(id1.is_ok());
        assert!(id2.is_ok());

        Ok(())
    }
}