use crate::db::connection::SqlitePool;
use crate::models::vulnerability::Vulnerability;
use rusqlite::params;
use std::sync::Arc;
use log::{error, debug};
use chrono::NaiveDate;
use anyhow::{Result, Context};
use tokio::task;

pub struct VulnerabilityRepository {
	pool: Arc<SqlitePool>,
}

impl VulnerabilityRepository {
	pub fn new(pool: Arc<SqlitePool>) -> Self {
		Self { pool }
	}

	pub async fn add_vulnerability(&self, vulnerability: Vulnerability) -> Result<i64> {
		let pool = self.pool.clone();
		task::spawn_blocking(move || {
			let conn = pool.get().context("Failed to get database connection")?;

			let published_date = vulnerability.published_date.map(|date| date.format("%Y-%m-%d").to_string());

			let result = conn.execute(
				"INSERT INTO vulnerabilities (cve_id, description, severity, impact, mitigation, published_date)
				 VALUES (?1, ?2, ?3, ?4, ?5, ?6)",
				params![
					vulnerability.cve_id,
					vulnerability.description,
					vulnerability.severity,
					vulnerability.impact,
					vulnerability.mitigation,
					published_date,
				],
			).context("Failed to execute INSERT query")?;

			if result != 1 {
				anyhow::bail!("Unexpected number of rows affected: {}", result);
			}

			let id = conn.last_insert_rowid();
			debug!("Inserted vulnerability with ID: {}", id);
			Ok(id)
		})
			.await
			.context("Failed to execute database operation")?
	}

	pub async fn get_all_vulnerabilities(&self) -> Result<Vec<Vulnerability>> {
		let pool = self.pool.clone();
		task::spawn_blocking(move || {
			let conn = pool.get().context("Failed to get database connection")?;

			let mut stmt = conn
				.prepare("SELECT vulnerability_id, cve_id, description, severity, impact, mitigation, published_date FROM vulnerabilities")
				.context("Failed to prepare SELECT query")?;

			let vulnerability_iter = stmt.query_map([], |row| {
				Ok(Vulnerability {
					vulnerability_id: row.get(0)?,
					cve_id: row.get(1)?,
					description: row.get(2)?,
					severity: row.get(3)?,
					impact: row.get(4)?,
					mitigation: row.get(5)?,
					published_date: row.get::<_, Option<String>>(6)?
						.and_then(|d| NaiveDate::parse_from_str(&d, "%Y-%m-%d").ok()),
				})
			})
				.context("Failed to execute SELECT query")?;

			vulnerability_iter
				.collect::<rusqlite::Result<Vec<_>>>()
				.context("Failed to collect vulnerabilities")
		})
			.await
			.context("Failed to execute database operation")?
	}

	pub async fn get_vulnerability_by_id(&self, id: i64) -> Result<Vulnerability> {
		let pool = self.pool.clone();
		task::spawn_blocking(move || {
			let conn = pool.get().context("Failed to get database connection")?;
			let mut stmt = conn.prepare(
				"SELECT vulnerability_id, cve_id, description, severity, impact, mitigation, published_date
				 FROM vulnerabilities WHERE vulnerability_id = ?"
			)?;

			stmt.query_row([id], |row| {
				Ok(Vulnerability {
					vulnerability_id: row.get(0)?,
					cve_id: row.get(1)?,
					description: row.get(2)?,
					severity: row.get(3)?,
					impact: row.get(4)?,
					mitigation: row.get(5)?,
					published_date: row.get::<_, Option<String>>(6)?
						.and_then(|d| NaiveDate::parse_from_str(&d, "%Y-%m-%d").ok()),
				})
			})
				.context("Failed to find vulnerability")
		})
			.await
			.context("Failed to execute database operation")?
	}

	pub async fn update_vulnerability(&self, vulnerability: &Vulnerability) -> Result<()> {
		let pool = self.pool.clone();
		let vulnerability = vulnerability.clone();
		task::spawn_blocking(move || {
			let conn = pool.get().context("Failed to get database connection")?;
			let published_date = vulnerability.published_date.map(|date| date.format("%Y-%m-%d").to_string());

			let result = conn.execute(
				"UPDATE vulnerabilities
				 SET cve_id = ?1, description = ?2, severity = ?3, impact = ?4, mitigation = ?5, published_date = ?6
				 WHERE vulnerability_id = ?7",
				params![
					vulnerability.cve_id,
					vulnerability.description,
					vulnerability.severity,
					vulnerability.impact,
					vulnerability.mitigation,
					published_date,
					vulnerability.vulnerability_id,
				],
			)?;

			if result != 1 {
				anyhow::bail!("Vulnerability not found or multiple rows affected");
			}
			Ok(())
		})
			.await
			.context("Failed to execute database operation")?
	}

	pub async fn delete_vulnerability(&self, id: i64) -> Result<()> {
		let pool = self.pool.clone();
		task::spawn_blocking(move || {
			let conn = pool.get().context("Failed to get database connection")?;
			let result = conn.execute("DELETE FROM vulnerabilities WHERE vulnerability_id = ?", [id])?;

			if result != 1 {
				anyhow::bail!("Vulnerability not found or multiple rows affected");
			}
			Ok(())
		})
			.await
			.context("Failed to execute database operation")?
	}

	pub async fn search_vulnerabilities(
		&self,
		query: &str,
		page: usize,
		page_size: usize
	) -> Result<(Vec<Vulnerability>, usize)> {
		let pool = self.pool.clone();
		let query = query.to_string();

		task::spawn_blocking(move || {
			let conn = pool.get().context("Failed to get database connection")?;

			// Get total count
			let mut count_stmt = conn.prepare(
				"SELECT COUNT(*) FROM vulnerabilities
				 WHERE cve_id LIKE ?1 OR description LIKE ?1"
			)?;

			let search_pattern = format!("%{}%", query);
			let total_count: i64 = count_stmt.query_row([&search_pattern], |row| row.get(0))?;
			let total_pages = (total_count as usize + page_size - 1) / page_size;

			// Get paginated results
			let mut stmt = conn.prepare(
				"SELECT vulnerability_id, cve_id, description, severity, impact, mitigation, published_date
				 FROM vulnerabilities
				 WHERE cve_id LIKE ?1 OR description LIKE ?1
				 LIMIT ?2 OFFSET ?3"
			)?;

			let vulnerability_iter = stmt.query_map(
				params![
					search_pattern,
					page_size as i64,
					(page * page_size) as i64
				],
				|row| {
					Ok(Vulnerability {
						vulnerability_id: row.get(0)?,
						cve_id: row.get(1)?,
						description: row.get(2)?,
						severity: row.get(3)?,
						impact: row.get(4)?,
						mitigation: row.get(5)?,
						published_date: row.get::<_, Option<String>>(6)?
							.and_then(|d| NaiveDate::parse_from_str(&d, "%Y-%m-%d").ok()),
					})
				},
			)?;

			let vulnerabilities = vulnerability_iter.collect::<rusqlite::Result<Vec<_>>>()?;
			Ok((vulnerabilities, total_pages))
		})
			.await
			.context("Failed to execute database operation")?
	}
}

#[cfg(test)]
mod tests {
	use super::*;
	use crate::db::connection;

	async fn setup_test_db() -> Result<Arc<SqlitePool>> {
		let pool = Arc::new(connection::establish_pool_with_path(
			std::path::PathBuf::from(":memory:")
		)?);

		// Create tables
		let conn = pool.get()?;
		conn.execute_batch(
			"CREATE TABLE IF NOT EXISTS vulnerabilities (
				vulnerability_id INTEGER PRIMARY KEY AUTOINCREMENT,
				cve_id TEXT UNIQUE NOT NULL,
				description TEXT,
				severity TEXT NOT NULL,
				impact TEXT,
				mitigation TEXT,
				published_date TEXT
			);"
		)?;

		Ok(pool)
	}

	#[tokio::test]
	async fn test_crud_operations() -> Result<()> {
		let pool = setup_test_db().await?;
		let repo = VulnerabilityRepository::new(pool);

		// Test Create
		let vuln = Vulnerability {
			vulnerability_id: None,
			cve_id: "CVE-2024-TEST".to_string(),
			description: Some("Test vulnerability".to_string()),
			severity: "HIGH".to_string(),
			impact: Some("Test impact".to_string()),
			mitigation: Some("Test mitigation".to_string()),
			published_date: Some(NaiveDate::from_ymd_opt(2024, 1, 1).unwrap()),
		};

		let id = repo.add_vulnerability(vuln.clone()).await?;
		assert!(id > 0);

		// Test Read
		let retrieved = repo.get_vulnerability_by_id(id).await?;
		assert_eq!(retrieved.cve_id, vuln.cve_id);

		// Test Search
		let (results, total_pages) = repo.search_vulnerabilities("TEST", 0, 10).await?;
		assert!(!results.is_empty());
		assert!(total_pages > 0);

		// Test Update
		let mut updated = retrieved.clone();
		updated.description = Some("Updated description".to_string());
		repo.update_vulnerability(&updated).await?;

		let retrieved_updated = repo.get_vulnerability_by_id(id).await?;
		assert_eq!(retrieved_updated.description, updated.description);

		// Test Delete
		repo.delete_vulnerability(id).await?;
		let result = repo.get_vulnerability_by_id(id).await;
		assert!(result.is_err());

		Ok(())
	}

	#[tokio::test]
	async fn test_concurrent_operations() -> Result<()> {
		let pool = setup_test_db().await?;
		let repo = VulnerabilityRepository::new(pool.clone());

		let handle1 = {
			let repo = VulnerabilityRepository::new(pool.clone());
			tokio::spawn(async move {
				let vuln = Vulnerability {
					vulnerability_id: None,
					cve_id: "CVE-2024-TEST1".to_string(),
					description: Some("Test 1".to_string()),
					severity: "HIGH".to_string(),
					impact: None,
					mitigation: None,
					published_date: None,
				};
				repo.add_vulnerability(vuln).await
			})
		};

		let handle2 = {
			let repo = VulnerabilityRepository::new(pool.clone());
			tokio::spawn(async move {
				let vuln = Vulnerability {
					vulnerability_id: None,
					cve_id: "CVE-2024-TEST2".to_string(),
					description: Some("Test 2".to_string()),
					severity: "MEDIUM".to_string(),
					impact: None,
					mitigation: None,
					published_date: None,
				};
				repo.add_vulnerability(vuln).await
			})
		};

		let (id1, id2) = tokio::join!(handle1, handle2);
		assert!(id1.unwrap().is_ok());
		assert!(id2.unwrap().is_ok());

		Ok(())
	}
}